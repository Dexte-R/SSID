/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `accounts` (
  `id` int(11) NOT NULL auto_increment,
  `login` varchar(255) NOT NULL,
  `hashed_password` varchar(255) NOT NULL,
  `salt` varchar(255) NOT NULL,
  `matric` varchar(255) NOT NULL,
  `name` varchar(255) NOT NULL,
  `expiry` datetime default NULL,
  `role` int(11) default '1',
  `ngram` int(11) NOT NULL default '4',
  `min_length` int(11) NOT NULL default '2',
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_accounts_on_matric` (`matric`),
  KEY `index_accounts_on_name` (`name`),
  KEY `index_accounts_on_login` (`login`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `accounts` VALUES (1,'admin','d4c75a4f637031f3588d01b5f1ea9fca5d7c9fe2','1301736000.8445554718420736','S000001L','Administrator','2020-12-31 15:59:59',0,4,2,'2012-06-18 09:23:20','2012-06-18 09:23:20'),(2,'instructor1','214f63d94555038dbe77bd73b1bb544e13bf9ff5','1492752400.020701726859894465','S000001A','Instructor 1','2020-12-31 15:59:59',1,4,2,'2012-06-18 09:23:20','2012-06-18 09:23:20'),(3,'instructor2','60bcda8932be0103094e3ee32005c4966e618b15','1491529400.7437282458990275','S000002B','Instructor 2','2020-12-31 15:59:59',1,4,2,'2012-06-18 09:23:20','2012-06-18 09:23:20'),(4,'ta1','50026fd2c032b85f824d7825ccb2f068b4d1b046','1490593200.8801491611223554','S000003C','Assistant 1','2020-12-31 15:59:59',1,4,2,'2012-06-18 09:23:20','2012-06-18 09:23:20'),(5,'ta2','743572deaf6f6936b38d656b8cd5027ac47e9837','1489727000.5770629841246263','S000004D','Assistant 2','2020-12-31 15:59:59',1,4,2,'2012-06-18 09:23:20','2012-06-18 09:23:20');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `announcements` (
  `id` int(11) NOT NULL auto_increment,
  `content` text,
  `account_id` int(11) NOT NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `announcements` VALUES (1,'Welcome to SSID. A plagiarism detection system developed in NUS.',1,'2012-06-18 09:23:20','2012-06-18 09:23:20');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `assignment_cluster_members` (
  `id` int(11) NOT NULL auto_increment,
  `assignment_cluster_id` int(11) NOT NULL,
  `assignment_code_id` int(11) NOT NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `members` (`assignment_cluster_id`,`assignment_code_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `assignment_clusterings` (
  `id` int(11) NOT NULL auto_increment,
  `assignment_id` int(11) default NULL,
  `remark` varchar(255) default NULL,
  `coc` decimal(6,3) default NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `index_assignment_clusterings_on_assignment_id_and_coc` (`assignment_id`,`coc`),
  KEY `index_assignment_clusterings_on_assignment_id` (`assignment_id`),
  KEY `index_assignment_clusterings_on_assignment_id_and_remark` (`assignment_id`,`remark`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `assignment_clusters` (
  `id` int(11) NOT NULL auto_increment,
  `assignment_clustering_id` int(11) default NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_assignment_clusters_on_assignment_clustering_id` (`assignment_clustering_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `assignment_codes` (
  `id` int(11) NOT NULL auto_increment,
  `code_line` int(11) default NULL,
  `code_array` longtext,
  `student_id` int(11) default NULL,
  `plagiarism` tinyint(1) NOT NULL default '0',
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_assignment_codes_on_student_id` (`student_id`),
  KEY `index_assignment_codes_on_student_id_and_plagiarism` (`student_id`,`plagiarism`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `assignment_codes` VALUES (1,172,'\'/** Class for a tree node\',\' */\',\'class MyNode {\',\'    // You may use this class if you\\\'d like.  It may help you if you use\',\'    // an array based implementation of a binary tree\',\'\',\'    // you can add other variables if you\\\'d like\',\'    boolean isSafe;				  // is the city safe?\',\'    int leftChildIndex;			  // left child index in array\',\'    int rightChildIndex;		 // right child index in array\',\'\',\'    // fill in your accessor and mutator methods here\',\'    // ...\',\'\',\'	public MyNode( int i ) {\',\'		if( i == 0 ) {\',\'			isSafe = false;\',\'		} else \',\'			isSafe = true;\',\'	}\',\'    \',\'	//accessors\',\'	public int getLeft(){\',\'		return leftChildIndex;\',\'	}\',\'\',\'	public int getRight(){\',\'		return rightChildIndex;\',\'	}\',\'	\',\'	//mutators\',\'	public void setLeft(int left){\',\'		this.leftChildIndex = left;\',\'	}\',\'\',\'	public void setRight (int right){\',\'		this.rightChildIndex = right;\',\'	}\',\'\',\'	public boolean isSafe(){\',\'		return isSafe;\',\'	}\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'    // You may want to use an array based implementation for \',\'    // your tree, or change this to another implementation\',\'\',\'    // Note that this code and the driver code do not necessarily\',\'    // match well -- you decide how you want these two parts to work\',\'    // together.\',\'\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;	// make sure to update this variable as needed\',\'\',\'    // fill in your ADT methods here\',\'    // ...\',\'\',\'	//insert the cities\',\'	public void insert (int n, int leftIndex, int rightIndex){\',\'		myTree[size] = new MyNode(n);\',\'		myTree[size].setLeft(leftIndex);\',\'		myTree[size].setRight(rightIndex);\',\'		size++;\',\'	}\',\'	\',\'	//use recursive methods to find result\',\'	public boolean queries(int depature, int arrive){\',\'		if (depature != arrive){\',\'			return queries(getParent(depature), 0)&& queries(getParent(arrive), 0)&& myTree[depature].isSafe && myTree[arrive].isSafe;\',\'		} else return myTree[depature].isSafe;\',\'	}\',\'\',\'	/*public boolean allSafe(int depature, int root){\',\'		if (departure == root){\',\'			return myTree[0].isSafe;\',\'		} else \',\'			return myTree[departure].isSafe && allSafe(getParent(depature), myTree[0]);\',\'	}*/\',\'\',\'	//method to find the parents of the city\',\'	public int getParent(int city){\',\'		for (int i = city;  i >=0; i --){\',\'			if(myTree[i].getRight() == city || myTree[i].getLeft() == city){\',\'				return i;\',\'			}\',\'		}\',\'		//return 0 if no parent, meaning this city is the root\',\'		return 0;\',\'	}\',\'}\',\'\',\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'public class CitiesDriver {\',\'    static Scanner sc;\',\'    //create all the array lists for storing all the input read\',\'	static int [] cities;\',\'	static int [] leftChild;\',\'	static int [] rightChild;\',\'	static int [] departCities;\',\'	static int [] arriveCities;\',\'	//initialize a Mytree instance\',\'	static MyTree tree = new MyTree();\',\'\',\'    /** Read in the tree\',\'     */\',\'    public static void readTree () {\',\'	/// Read in the tree\',\'	// read in one integer\',\'	int n = sc.nextInt();\',\'	// read in tree, safety line\',\'	\',\'	cities = new int [n];\',\'	//read in the cities\',\'	for (int i=0;i<n;i++) { \',\'	    cities[i] = sc.nextInt();\',\'	}// modify this line\',\'	\',\'	// loop to read pairs of children\',\'	leftChild = new int [n];\',\'	rightChild = new int [n];\',\'	for (int i=0;i<n;i++) {\',\'	    leftChild [i] = sc.nextInt();			   // modify this line\',\'	    rightChild [i] = sc.nextInt();			   // modify this line\',\'	}\',\'	\',\'	//insert all the cities with their data into the mytree;\',\'	// datas are like if they are safe or not, then its left city and right city\',\'	for (int i =0; i < n; i++){\',\'		tree.insert(cities[i], leftChild[i], rightChild[i]);\',\'	}\',\'    }\',\'    \',\'    /** Read in query statements\',\'     */\',\'    public static void readQueries () {\',\'	// read in one integer\',\'	int m = sc.nextInt();\',\'	// loop to read pairs of children for query\',\'\',\'	departCities = new int [m];\',\'	arriveCities = new int [m];\',\'	for (int i=0;i<m;i++) {\',\'	    departCities [i] = sc.nextInt();			   // modify this line\',\'	    arriveCities [i] = sc.nextInt();			   // modify this line\',\'	}\',\'    }\',\'    \',\'    public static void main(String[] args) {\',\'	sc = new Scanner(System.in);\',\'	readTree();				   // read in the tree\',\'	readQueries();				// read in the queries\',\'	\',\'	int numOfQueries = departCities.length;\',\'	for (int i =0; i < numOfQueries ; i ++){\',\'		boolean isSafe = tree.queries(departCities[i], arriveCities[i]);\',\'		if (isSafe) {\',\'			System.out.println(\"YES\");\',\'		} else System.out.println(\"NO\");\',\'	}\',\'	// then process the queries ... fill in your calls below\',\'    }\',\'}\',\'\'',1,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(2,160,'\'import java.util.*;\',\'\',\'\',\'public class CitiesDriver {\',\'	static Scanner scanner;\',\'	static MyTree tree;\',\'\',\'\',\'\',\'	public static void readTree () {\',\'		\',\'		int n = scanner.nextInt();\',\'		tree = new MyTree(n);			\',\'	\',\'\',\'        int i = 0;\',\'        while(i<n){\',\'			int safe = scanner.nextInt();\',\'			tree.updateSafety(i, safe);\',\'            i++;\',\'        }\',\'\',\'		int y=0;\',\'        while(y<n){\',\'			int left = scanner.nextInt();\',\'			int right = scanner.nextInt();\',\'			tree.updateNode(y,left,right);\',\'            y++;\',\'        }\',\'	}\',\'\',\'	public static void readQueries () {\',\'		\',\'		int m = scanner.nextInt();\',\'		\',\'		for (int i=0;i<m;i++) {\',\'			int start = scanner.nextInt();\',\'			int end = scanner.nextInt();\',\'			if (tree.isPathSafe(start,end)==true)\',\'				System.out.println(\"YES\");\',\'			else\',\'				System.out.println(\"NO\");\',\'		}\',\'	}\',\'\',\'	public static void main(String[] args) {\',\'		scanner = new Scanner(System.in);\',\'		readTree();				  \',\'		readQueries();				\',\'	}\',\'}\',\'/* \',\'*/\',\'\',\'import java.util.*;\',\'\',\'class MyNode {\',\'    boolean isCitySafe;				\',\'\',\'    int leftChildIndex;			 \',\'    int rightChildIndex;		\',\'	int parentIndex;\',\'\',\'    public boolean isIsCitySafe() {\',\'        return isCitySafe;\',\'    }\',\'\',\'    public void setIsCitySafe(boolean isCitySafe) {\',\'        this.isCitySafe = isCitySafe;\',\'    }\',\'\',\'	public void setLeft(int left){\',\'		leftChildIndex = left;\',\'	}\',\'	public void setRight(int right){\',\'		rightChildIndex = right;\',\'	}\',\'	public void setParent(int parent){\',\'		parentIndex = parent;\',\'	}\',\'	public int getLeft(){\',\'		return leftChildIndex;\',\'	}\',\'	public int getRight(){\',\'		return rightChildIndex;\',\'	}\',\'	public int getParent(){\',\'		return parentIndex;\',\'	}\',\'}\',\'\',\' \',\'public class MyTree {\',\'   \',\'\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;\',\'	int root = 0;\',\'	LinkedList <Integer> q;		\',\'\',\'\',\'	public MyTree(int n){\',\'		for (int i = 0; i < n; i++)\',\'			myTree[i] = new MyNode();\',\'		size = n;\',\'	}\',\'	public void updateSafety(int node, int safe){\',\'		myTree[node].setIsCitySafe(safe == 1);\',\'	}\',\'	public void updateNode(int node, int left, int right){\',\'		myTree[node].setLeft(left);\',\'		myTree[node].setRight(right);\',\'		if (left != -1)\',\'			myTree[left].setParent(node);\',\'		if (right != -1)\',\'			myTree[right].setParent(node);\',\'	}\',\'\',\'	public boolean isPathSafe(int start, int end){\',\'		int[] pre = new int[size];			\',\'		boolean[] visited = new boolean[size];\',\'		q = new LinkedList <Integer>();\',\'	\',\'		q.offer(new Integer(start));\',\'		visited[start] = true;\',\'		while (q.size()!=0){\',\'			int u = q.poll();\',\'			if (u == end)\',\'				break;\',\'			int left = myTree[u].getLeft();\',\'			int right = myTree[u].getRight();\',\'			int parent = myTree[u].getParent();\',\'			if (left != -1 && visited[left] == false){\',\'				visited[left] = true;\',\'				q.offer(new Integer(left));\',\'				pre[left] = u;\',\'			}\',\'			if (right != -1 && visited[right] == false){\',\'				visited[right] = true;\',\'				q.offer(new Integer(right));\',\'				pre[right] = u;\',\'			}\',\'			if (parent != -1 && visited[parent] == false){\',\'				visited[parent] = true;\',\'				q.offer(new Integer(parent));\',\'				pre[parent] = u;\',\'			}\',\'		}\',\'		int curnode = end;\',\'	\',\'		boolean isCitySafe = myTree[start].isIsCitySafe();\',\'		while (curnode != start){\',\'			isCitySafe = myTree[curnode].isIsCitySafe() && isCitySafe;\',\'			curnode = pre[curnode];\',\'		}\',\'		return isCitySafe;\',\'	}\',\'}\',\'\'',2,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(3,183,'\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'public class CitiesDriver {\',\'	static Scanner sc;\',\'	static MyTree tree;\',\'\',\'	/** Read in the tree\',\'	 */\',\'	public static void readTree () {\',\'		// Read in the tree\',\'		// Read in size of the tree\',\'		int n = sc.nextInt();\',\'		tree = new MyTree(n);			//Create MyTree with n nodes\',\'		// read in tree, safety line\',\'		for (int i=0;i<n;i++){ \',\'			int safe = sc.nextInt();\',\'			tree.updateSafety(i, safe);\',\'		}\',\'\',\'		// loop to read pairs of children\',\'		for (int i=0;i<n;i++) {\',\'			int left = sc.nextInt();\',\'			int right = sc.nextInt();\',\'			tree.updateNode(i,left,right);\',\'		}\',\'	}\',\'\',\'	/** Read in query statements\',\'	 */\',\'	public static void readQueries () {\',\'		// read in one integer\',\'		int m = sc.nextInt();\',\'		// loop to read pairs of children for query\',\'		for (int i=0;i<m;i++) {\',\'			int start = sc.nextInt();\',\'			int end = sc.nextInt();\',\'			if (tree.isPathSafe(start,end)==true)\',\'				System.out.println(\"YES\");\',\'			else\',\'				System.out.println(\"NO\");\',\'		}\',\'	}\',\'\',\'	public static void main(String[] args) {\',\'		sc = new Scanner(System.in);\',\'		readTree();				   // read in the tree\',\'		readQueries();				// read in the queries\',\'	}\',\'}\',\'/* \',\'Class for a tree node\',\'*/\',\'\',\'import java.util.*;\',\'class MyNode {\',\'    boolean isSafe;				  // is the city safe?\',\'    int leftChildIndex;			  // left child index in array\',\'    int rightChildIndex;		 // right child index in array\',\'	int parentIndex;\',\'\',\'	//All the accessors and mutators\',\'	//Boring stuff\',\'	public void setIsSafe(boolean safe){\',\'		isSafe = safe;\',\'	}\',\'	public void setLeft(int left){\',\'		leftChildIndex = left;\',\'	}\',\'	public void setRight(int right){\',\'		rightChildIndex = right;\',\'	}\',\'	public void setParent(int parent){\',\'		parentIndex = parent;\',\'	}\',\'	public int getLeft(){\',\'		return leftChildIndex;\',\'	}\',\'	public int getRight(){\',\'		return rightChildIndex;\',\'	}\',\'	public int getParent(){\',\'		return parentIndex;\',\'	}\',\'	public boolean getIsSafe(){\',\'		return isSafe;\',\'	}\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'    // You may want to use an array based implementation for \',\'    // your tree, or change this to another implementation\',\'\',\'    // Note that this code and the driver code do not necessarily\',\'    // match well -- you decide how you want these two parts to work\',\'    // together.\',\'\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;\',\'	int root = 0;\',\'	LinkedList <Integer> q;			//Queue for BFS\',\'\',\'	/*\',\'	Fill up the tree with the nodes and set the size of the tree\',\'	Even more boring stuff\',\'	*/\',\'	public MyTree(int n){\',\'		for (int i = 0; i < n; i++)\',\'			myTree[i] = new MyNode();\',\'		size = n;\',\'	}\',\'	public void updateSafety(int node, int safe){\',\'		myTree[node].setIsSafe(safe == 1);\',\'	}\',\'	public void updateNode(int node, int left, int right){\',\'		myTree[node].setLeft(left);\',\'		myTree[node].setRight(right);\',\'		if (left != -1)\',\'			myTree[left].setParent(node);\',\'		if (right != -1)\',\'			myTree[right].setParent(node);\',\'	}\',\'	/*\',\'	In this problem, we are given a tree. Therefore, given any nodes u and v, there is only one unique path from u to v.\',\'	This is because a tree is acyclic and all the nodes are connected. The question asks whether it is possible to find a \',\'	\"safe\" path from nodes u to v. \',\'\',\'	The easiest way to solve this problem would be to view the binary tree as a graph instead of a binary tree and run BFS/DFS \',\'	on the tree. Personally I prefer coding BFS, hence I coded BFS. I used the binary tree structure as an adjacency list, where\',\'	there is an edge from the current node to its left child, an edge from the current node to its right child and an edge from the \',\'	current node to its parent.\',\'\',\'	After running BFS, I recreate the path using the array pre[] (which stores the predecessor of the node) and check whether the\',\'	path is safe. The runtime for BFS is O(N) for every query (where N is the size of binary tree). Suppose there are M queries, then\',\'	it will take O(MN) to run all M queries.\',\'	*/\',\'	public boolean isPathSafe(int start, int end){\',\'		int[] pre = new int[size];				//Stores who is the pre of the current node in the path\',\'		boolean[] visited = new boolean[size];	//To store whether the particular node is visited\',\'		q = new LinkedList <Integer>();\',\'		//Start of BFS\',\'		q.offer(new Integer(start));\',\'		visited[start] = true;\',\'		while (q.size()!=0){\',\'			int u = q.poll();\',\'			if (u == end)\',\'				break;\',\'			int left = myTree[u].getLeft();\',\'			int right = myTree[u].getRight();\',\'			int parent = myTree[u].getParent();\',\'			if (left != -1 && visited[left] == false){\',\'				visited[left] = true;\',\'				q.offer(new Integer(left));\',\'				pre[left] = u;\',\'			}\',\'			if (right != -1 && visited[right] == false){\',\'				visited[right] = true;\',\'				q.offer(new Integer(right));\',\'				pre[right] = u;\',\'			}\',\'			if (parent != -1 && visited[parent] == false){\',\'				visited[parent] = true;\',\'				q.offer(new Integer(parent));\',\'				pre[parent] = u;\',\'			}\',\'		}\',\'		int curnode = end;\',\'		//If the path is safe, then logical and of all the nodes in the path will yield whether the path is safe\',\'		boolean isSafe = myTree[start].getIsSafe();\',\'		while (curnode != start){\',\'			isSafe = myTree[curnode].getIsSafe() && isSafe;\',\'			curnode = pre[curnode];\',\'		}\',\'		return isSafe;\',\'	}\',\'}\',\'\'',3,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(4,118,'\'/** Class for a tree node\',\' */\',\'class MyNode {\',\'    // A reference  based implementation of a binary tree\',\'\',\'    boolean isSafe;         // is the city safe?\',\'    int city;\',\'    MyNode leftChild;			  // left child \',\'    MyNode rightChild;		 // right child\',\'    \',\'\',\'	public MyNode (int newCity) {\',\'		//initializes tree node with city and no children\',\'		city = newCity;\',\'		leftChild = null;\',\'		rightChild = null;\',\'	}//end constructor\',\'    \',\'	public MyNode (int newCity, MyNode left, MyNode right) {\',\'		city = newCity;\',\'		leftChild = left;\',\'		rightChild = right;\',\'	}//end constructor\',\'\',\'	public void setCity (int newCity) {\',\'		city = newCity;\',\'	}//end setCity\',\'\',\'	public void setLeft (MyNode left) {\',\'		//sets left child reference to left\',\'		leftChild = left;\',\'	}//end setLeft\',\'\',\'	public void setRight (MyNode right) {\',\'		//sets right child reference to right\',\'		rightChild = right;\',\'	}//end setRight\',\'\',\'	public boolean setIsSafe (int flag) {  //according to flag value sets isSafe\',\'		if (flag==0)\',\'			return isSafe = false;\',\'		else \',\'			return isSafe = true;\',\'	}//end setIsSafe\',\'\',\'\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'    private MyNode root;\',\'\',\'	public MyTree (MyNode newRoot) {\',\'          root = new MyNode (newRoot);\',\'	}//end constructor \',\'\',\'	public MyTree (MyNode newRoot, MyNode left, MyNode right) {\',\'       root = new MyNode (newRoot, left, right);\',\'	}//end constructor\',\'\',\'	public void attachLeft (int city) {\',\'       root.setLeft(new MyNode (city, null, null));\',\'	}//end attachLeft\',\'\',\'    public void attachRight (int city) {\',\'		root.setRight (new MyNode (city, null, null));\',\'    }//end attachRight\',\'\',\'\',\'}//end MyTree\',\'\',\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'public class CitiesDriver {\',\'    static Scanner sc;\',\'    \',\'    /** Read in the tree\',\'     */\',\'    public static void readTree () {\',\'	/// Read in the tree\',\'	// read in one integer\',\'	int n = sc.nextInt();\',\'	// read in tree, safety line\',\'	for (int i=0;i<n;i++) \',\'	    sc.nextInt();			   // modify this line\',\'	\',\'	// loop to read pairs of children\',\'	for (int i=0;i<n;i++) {\',\'	    sc.nextInt();			   // modify this line\',\'	    sc.nextInt();			   // modify this line\',\'	}\',\'    }\',\'    \',\'    /** Read in query statements\',\'     */\',\'    public static void readQueries () {\',\'	// read in one integer\',\'	int m = sc.nextInt();\',\'	// loop to read pairs of children for query\',\'	for (int i=0;i<m;i++) {\',\'	    sc.nextInt();			   // modify this line\',\'	    sc.nextInt();			   // modify this line\',\'	}\',\'    }\',\'    \',\'    public static void main(String[] args) {\',\'	sc = new Scanner(System.in);\',\'	readTree();				   // read in the tree\',\'	readQueries();				// read in the queries\',\'\',\'	// then process the queries ... fill in your calls below\',\'    }\',\'}\'',4,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(5,184,'\'import java.util.*;\',\'\',\'/**\',\' * Driver class\',\' */\',\'\',\'public class CitiesDriver {\',\'\',\'    static Scanner sc;\',\'	static MyTree tree;\',\'\',\'    // Read in the tree\',\'    public static void readTree () {\',\'		\',\'		// Read in the tree\',\'		// read in one integer\',\'		int n = sc.nextInt();\',\'	\',\'		tree = new MyTree (n);\',\'\',\'		// read in tree, safety line\',\'		for (int i = 0; i < n; i++) {\',\'	    	tree.setSafe(i,sc.nextInt());\',\'		}\',\'	\',\'		// loop to read pairs of children\',\'		for (int i = 0; i < n; i++) {\',\'	    	tree.setNode(i,sc.nextInt(),sc.nextInt());\',\'		}\',\'\',\'		//tree.print();\',\'\',\'    }\',\'    \',\'    // Read in query statements\',\'    public static void readQueries () {\',\'		\',\'		// read in one integer\',\'		int m = sc.nextInt();\',\'		\',\'		// loop to read pairs of children for query\',\'		for (int i=0;i<m;i++) {\',\'	    	if (tree.findpath(sc.nextInt(),sc.nextInt()))\',\'				System.out.println(\"YES\");\',\'			else System.out.println(\"NO\");\',\'		}\',\'\',\'    }\',\'    \',\'    public static void main(String[] args) {\',\'		sc = new Scanner(System.in);\',\'		readTree();				   // read in the tree\',\'		readQueries();				// read in the queries\',\'\',\'    }\',\'\',\'}\',\'/** Class for a tree node\',\' */\',\'class MyNode {\',\'\',\'    boolean isSafe;				  // is the city safe?\',\'    int left;			  // left child index in array\',\'    int right;		 // right child index in array\',\'\',\'    public MyNode () {\',\'		isSafe = true;\',\'		left = -1;\',\'		right = -1;\',\'	}\',\'\',\'	public int left () {\',\'		return left;\',\'	}\',\'\',\'	public int right () {\',\'		return right;\',\'	}\',\'\',\'	public boolean isSafe () {\',\'		return isSafe;\',\'	}\',\'\',\'	public void setSafe (int n) {\',\'		if (n == 0) isSafe = false;\',\'		else if (n == 1) isSafe = true;\',\'	}\',\'\',\'	public void setLeft (int index) {\',\'		left = index;\',\'	}\',\'\',\'	public void setRight (int index) {\',\'		right = index;\',\'	}\',\'\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;\',\'\',\'	public MyTree (int n) {\',\'		size = n;\',\'		for (int i = 0; i < n; i++) {\',\'			myTree[i] = new MyNode ();\',\'		}\',\'	}\',\'\',\'	public void setSafe (int index, int status) {\',\'		myTree[index].setSafe(status);\',\'	}\',\'\',\'	public void setNode (int index, int left, int right) {\',\'		myTree[index].setLeft(left);\',\'		myTree[index].setRight(right);\',\'	}\',\'\',\'	public void print () {\',\'		print(myTree,0);\',\'	}\',\'\',\'	public boolean findpath (int from, int to) {\',\'		if (!myTree[from].isSafe() || !myTree[to].isSafe()) {\',\'			return false;\',\'		}\',\'\',\'		if (from == to) return true;\',\'\',\'		if (directPath(from,to)) return true;\',\'\',\'		if (directPath(to,from)) return true;\',\'\',\'		if (directPath(0,from) && directPath(0,to)) return true;\',\'\',\'		return false;\',\'	}\',\'\',\'	public boolean directPath (int index, int target) {\',\'		if (index >= 0) {\',\'			if (!myTree[index].isSafe()) return false;\',\'			else {\',\'				if (index == target) return true;\',\'\',\'				if (directPath(myTree[index].left(),target)) return true;\',\'				else return directPath(myTree[index].right(),target);\',\'			}\',\'		}\',\'\',\'		return false;\',\'	}\',\'\',\'	public boolean search (int index, int target) {\',\'\',\'		if (index >= 0) {\',\'			if (index == target) return true;\',\'\',\'			if (search(myTree[index].left(),target)) return false;\',\'			else return search(myTree[index].right(),target);\',\'		}\',\'\',\'		return false;\',\'	}\',\'\',\'	public void print (MyNode[] tree, int index) {\',\'		\',\'		if (index >= 0) {\',\'			print(tree,tree[index].left());\',\'\',\'			System.out.print(index);\',\'			if (!tree[index].isSafe()) System.out.print(\"*\");\',\'			System.out.print(\" \");\',\'\',\'			print(tree,tree[index].right());\',\'		}\',\'\',\'	}\',\'\',\'}\',\'\'',5,1,'2012-06-18 18:30:59','2012-06-18 10:35:32'),(6,101,'\'import java.util.*;\',\'/** Class for a tree node\',\' */\',\'class MyNode{\',\'    boolean isSafe;				  // is the city safe?\',\'    int leftChildIndex;			  // left child index in array\',\'    int rightChildIndex;		 // right child index in array\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;	// make sure to update this variable as needed\',\'\',\'	public void updateSafety(int cityIndex, int safe)\',\'	{myTree[cityIndex]=new MyNode();\',\'	 size++;\',\'	 if(safe==0)\',\'	   myTree[cityIndex].isSafe=false;\',\'	 else myTree[cityIndex].isSafe=true;\',\'	}\',\'\',\'	public void updateChild(int cityIndex, int left, int right)\',\'	{myTree[cityIndex].leftChildIndex=left;\',\'	 myTree[cityIndex].rightChildIndex=right;\',\'	}\',\'\',\'	public boolean safePath(int start, int end)\',\' 	{if(myTree[start].isSafe==false)\',\'	      return false;\',\'     else if(myTree[end].isSafe==false)\',\'          return false;\',\'     else if(start==end)\',\'		 return true;\',\'	 else \',\'	   {for(int i=0;i<size;i++)\',\'		  if(myTree[i].leftChildIndex==start||myTree[i].rightChildIndex==start&&myTree[i].isSafe==true)\',\'		      return safePath(i, end);\',\'		   else if(myTree[i].leftChildIndex==end||myTree.rightChildIndex==end&&myTree[i].isSafe==true)\',\'			   return safePath(start, i);\',\'			  \',\'	      else return false;}\',\'	}\',\'}\',\'\',\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'public class CitiesDriver {\',\'    static Scanner sc;\',\'    static MyTree mt;\',\'    /** Read in the tree\',\'     */\',\'    public static void readTree () {\',\'	/// Read in the tree\',\'	// read in one integer\',\'	int n = sc.nextInt();\',\'	// read in tree, safety line\',\'	for (int i=0;i<n;i++) {\',\'	   int safety=sc.nextInt();\',\'       mt.updateSafety(i,safety);}\',\'	\',\'	// loop to read pairs of children\',\'	for (int i=0;i<n;i++) {\',\'	   int left=sc.nextInt();			  \',\'	   int right=sc.nextInt();\',\'	   mt.updateChild(i,left,right);\',\'	  }\',\'    }\',\'    \',\'    /** Read in query statements\',\'     */\',\'    public static void readQueries () {\',\'	// read in one integer\',\'	int m = sc.nextInt();\',\'	// loop to read pairs of children for query\',\'	for (int i=0;i<m;i++) {\',\'	    int start=sc.nextInt();			  \',\'	    int end=sc.nextInt();\',\'		boolean exist=mt.safePath(start,end);\',\'		if(exist==true)\',\'			System.out.println(\"Yes\");\',\'	    else System.out.println(\"No\");\',\'	}\',\'    }\',\'    \',\'    public static void main(String[] args) {\',\'	sc = new Scanner(System.in);\',\'	mt=new MyTree();\',\'	readTree();				   // read in the tree\',\'	readQueries();				// read in the queries\',\'\',\'	// then process the queries ... fill in your calls below\',\'    }\',\'}\',\'\'',6,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(7,191,'\'import java.util.*;\',\'\',\'/**\',\' * Driver class\',\' */\',\'\',\'public class CitiesDriver {\',\'\',\'    public static Scanner sc;\',\'    public static MyTree tree;\',\'\',\'    // Read in the tree\',\'    public static void readTree () {\',\'		\',\'		// Read in the tree\',\'		// read in one integer\',\'		int read1Integer  = sc.nextInt();\',\'	\',\'		tree = new MyTree (read1Integer );\',\'\',\'		// read in tree, safety line\',\'		for (int i = 0; i < read1Integer ; i++) {\',\'	    		tree.setSafe(i,sc.nextInt());\',\'		}\',\'	\',\'		// loop to read pairs of children\',\'		for (int i = 0; i < read1Integer ; i++) {\',\'	    		tree.setNode(i,sc.nextInt(),sc.nextInt());\',\'		}\',\'\',\'		\',\'\',\'    }\',\'    \',\'    // Read in query statements\',\'    public static void readQueries () {\',\'		\',\'		// read in one integer\',\'		int read1Integer = sc.nextInt();\',\'		\',\'		// loop to read pairs of children for query\',\'		for (int i=0;i<read1Integer;i++) {\',\'	    	if (tree.findpath(sc.nextInt(),sc.nextInt())){\',\'				System.out.println(\"YES\");\',\'		}\',\'			else {\',\'				System.out.println(\"NO\");\',\'			}\',\'		}\',\'\',\'    }\',\'    \',\'    public static void main(String[] args) {\',\'		sc = new Scanner(System.in);\',\'		readTree();				   // read in the tree\',\'		readQueries();				// read in the queries\',\'\',\'    }\',\'\',\'}\',\'/** Class for a tree node\',\' */\',\'class MyNode {\',\'\',\'    boolean isSafe;				  // is the city safe?\',\'    int left;			  // left child index in array\',\'    int right;		 // right child index in array\',\'\',\'    public MyNode () {\',\'		isSafe = true;\',\'		left = -1;\',\'		right = -1;\',\'	}\',\'\',\'	public int left () {\',\'		return left;\',\'	}\',\'\',\'	public int right () {\',\'		return right;\',\'	}\',\'\',\'	public boolean isSafe () {\',\'		return isSafe;\',\'	}\',\'\',\'	public void setSafe (int n) {\',\'		if (n == 0) isSafe = false;\',\'		else if (n == 1) isSafe = true;\',\'	}\',\'\',\'	public void setLeft (int index) {\',\'		left = index;\',\'	}\',\'\',\'	public void setRight (int index) {\',\'		right = index;\',\'	}\',\'\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;\',\'\',\'	public MyTree (int n) {\',\'		size = n;\',\'		for (int i = 0; i < n; i++) {\',\'			myTree[i] = new MyNode ();\',\'		}\',\'	}\',\'\',\'	public void setSafe (int index, int status) {\',\'		myTree[index].setSafe(status);\',\'	}\',\'\',\'	public void setNode (int index, int left, int right) {\',\'		myTree[index].setLeft(left);\',\'		myTree[index].setRight(right);\',\'	}\',\'\',\'	public void print () {\',\'		print(myTree,0);\',\'	}\',\'\',\'	public boolean findpath (int from, int to) {\',\'		if (!myTree[from].isSafe() || !myTree[to].isSafe()) {\',\'			return false;\',\'		}\',\'\',\'		if (from == to) return true;\',\'\',\'		if (directPath(from,to)) return true;\',\'\',\'		if (directPath(to,from)) return true;\',\'\',\'		if (directPath(0,from) && directPath(0,to)) return true;\',\'\',\'		return false;\',\'	}\',\'\',\'	public boolean directPath (int index, int target) {\',\'		if (index >= 0) {\',\'			if (!myTree[index].isSafe()) return false;\',\'			else {\',\'				if (index == target) return true;\',\'\',\'				if (directPath(myTree[index].left(),target)) return true;\',\'				else return directPath(myTree[index].right(),target);\',\'			}\',\'		}\',\'\',\'		return false;\',\'	}\',\'\',\'	public boolean searchTree (int index, int target) {\',\'\',\'		if (index >= 0) {\',\'			if (index == target) return true;\',\'\',\'			if (searchTree(myTree[index].left(),target)){ \',\'				return false;\',\'			}\',\'			else{\',\'				return searchTree(myTree[index].right(),target);\',\'			}\',\'		}\',\'\',\'		return false;\',\'	}\',\'\',\'	public void print (MyNode[] tree, int index) {\',\'		\',\'		if (index >= 0) {\',\'			print(tree,tree[index].left());\',\'\',\'			System.out.print(index);\',\'			if (!tree[index].isSafe()) System.out.print(\"*\");\',\'			System.out.print(\" \");\',\'\',\'			print(tree,tree[index].right());\',\'		}\',\'\',\'	}\',\'\',\'}\',\'\'',7,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(8,194,'\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'public class CitiesDriver {\',\' static Scanner sc;\',\' static MyTree tree;\',\' \',\' \',\' public static void main(String[] args) {\',\'  sc = new Scanner(System.in);\',\'  \',\'  readTree();       // read in the tree\',\'  readQ();    // read in the queries\',\' }\',\' \',\' \',\' \',\' /** Read in query statements\',\'  */\',\' public static void readQ () {\',\'  // read in one integer\',\'  int j = sc.nextInt();\',\'  // loop to read pairs of children for query\',\'  for (int i=0;i<j;i++) {\',\'   int start = sc.nextInt();\',\'   int end = sc.nextInt();\',\'   if (tree.isPathOk(start,end)!=true)\',\'    System.out.println(\"NO\");\',\'   else\',\'    System.out.println(\"YES\");\',\'  }\',\' }\',\'\',\' /** Read in the tree\',\'  */\',\' public static void readTree () {\',\'  // Read in the tree\',\'  // Read in size of the tree\',\'  int n = sc.nextInt();\',\'  tree = new MyTree(n);   //Create MyTree with n nodes\',\'  // read in tree, safety line\',\'  for (int j=0;j<n;j++){   \',\'   int ok = sc.nextInt();\',\'   tree.updateSafety(j, ok);\',\'  }\',\'\',\'  // loop to read pairs of children\',\'  for (int j=0;j<n;j++) {\',\'   int left = sc.nextInt();\',\'   int right = sc.nextInt();\',\'   tree.updateNode(j,left,right);\',\'  }\',\' }\',\'\',\'\',\' \',\'}\',\'/* \',\' Class for a tree node\',\' */\',\'\',\'import java.util.*;\',\'class MyNode {\',\'  boolean isSafe;      // is the city safe?\',\'  int leftChild;     // left child index in array\',\'  int rightChild;   // right child index in array\',\'  int parent;\',\'  \',\'  //All the accessors and mutators\',\'  //Boring stuff\',\'  public void setIsSafe(boolean safe){\',\'    isSafe = safe;\',\'  }\',\'  public void setLeft(int left){\',\'    leftChild = left;\',\'  }\',\'  public void setRight(int right){\',\'    rightChild = right;\',\'  }\',\'  public void setParent(int parent){\',\'    parent = parent;\',\'  }\',\'  public int getLeft(){\',\'    return leftChild;\',\'  }\',\'  public int getRight(){\',\'    return rightChild;\',\'  }\',\'  public int getParent(){\',\'    return parent;\',\'  }\',\'  public boolean getIsSafe(){\',\'    return isSafe;\',\'  }\',\'}\',\'\',\'/** Class for a binary tree ADT\',\'  */\',\'public class MyTree {\',\'  // You may want to use an array based implementation for \',\'  // your tree, or change this to another implementation\',\'  \',\'  // Note that this code and the driver code do not necessarily\',\'  // match well -- you decide how you want these two parts to work\',\'  // together.\',\'  \',\'  private final int MAX_NODES = 1000;\',\'  MyNode[] myTree = new MyNode[MAX_NODES];\',\'  int size = 0;\',\'  int root = 0;\',\'  LinkedList <Integer> q;   //Queue for BFS\',\'  \',\'  /*\',\'   Fill up the tree with the nodes and set the size of the tree\',\'   Even more boring stuff\',\'   */\',\'  \',\'  public void updateNode(int node, int left, int right){\',\'    myTree[node].setLeft(left);\',\'    myTree[node].setRight(right);\',\'    if (left != -1)\',\'      myTree[left].setParent(node);\',\'    if (right != -1)\',\'      myTree[right].setParent(node);\',\'  }\',\'  public MyTree(int n){\',\'    for (int i = 0; i < n; i++)\',\'      myTree[i] = new MyNode();\',\'    size = n;\',\'  }\',\'  public void updateSafety(int node, int safe){\',\'    myTree[node].setIsSafe(safe == 1);\',\'  }\',\'  \',\'  /*\',\'   In this problem, we are given a tree. Therefore, given any nodes u and v, there is only one unique path from u to v.\',\'   This is because a tree is acyclic and all the nodes are connected. The question asks whether it is possible to find a \',\'   \"safe\" path from nodes u to v. \',\'   \',\'   The easiest way to solve this problem would be to view the binary tree as a graph instead of a binary tree and run BFS/DFS \',\'   on the tree. Personally I prefer coding BFS, hence I coded BFS. I used the binary tree structure as an adjacency list, where\',\'   there is an edge from the current node to its left child, an edge from the current node to its right child and an edge from the \',\'   current node to its parent.\',\'   \',\'   After running BFS, I recreate the path using the array pre[] (which stores the predecessor of the node) and check whether the\',\'   path is safe. The runtime for BFS is O(N) for every query (where N is the size of binary tree). Suppose there are M queries, then\',\'   it will take O(MN) to run all M queries.\',\'   */\',\'  public boolean isPathOk(int start, int end){\',\'    int[] pre = new int[size];    //Stores who is the pre of the current node in the path\',\'    boolean[] visited = new boolean[size]; //To store whether the particular node is visited\',\'    q = new LinkedList <Integer>();\',\'    //Start of BFS\',\'    q.offer(new Integer(start));\',\'    visited[start] = true;\',\'    while (q.size()!=0){\',\'      int u = q.poll();\',\'      if (u == end)\',\'        break;\',\'      \',\'      int right = myTree[u].getRight();\',\'      int left = myTree[u].getLeft();      \',\'      int parent = myTree[u].getParent();\',\'      \',\'      if (right != -1 && visited[right] == false){\',\'        visited[right] = true;\',\'        q.offer(new Integer(right));\',\'        pre[right] = u;\',\'      }\',\'      if (left != -1 && visited[left] == false){\',\'        visited[left] = true;\',\'        q.offer(new Integer(left));\',\'        pre[left] = u;\',\'      }\',\'      if (parent != -1 && visited[parent] == false){\',\'        visited[parent] = true;\',\'        q.offer(new Integer(parent));\',\'        pre[parent] = u;\',\'      }\',\'    }\',\'    int curnode = end;\',\'    //If the path is safe, then logical and of all the nodes in the path will yield whether the path is safe\',\'    boolean isSafe = myTree[start].getIsSafe();\',\'    while (curnode != start){\',\'      isSafe = myTree[curnode].getIsSafe() && isSafe;\',\'      curnode = pre[curnode];\',\'    }\',\'    return isSafe;\',\'  }\',\'}\',\'\'',8,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(9,143,'\'/** Class for a tree node\',\' */\',\' \',\'// This class is actually MyNode class although it is called MyTree\',\'\',\'public class MyTree {\',\'\',\'    // data field\',\'	public int city;         // id of the city\',\'    public boolean isSafe;	 // is the city safe?\',\'    public int leftIndex;    // left child index in array\',\'    public int rightIndex;   // right child index in array\',\'	\',\'	// constructor\',\'	public MyTree( int id) {\',\'		city = id;\',\'		isSafe = false;\',\'		leftIndex = -1;\',\'		rightIndex = -1;\',\'	}\',\'} // end MyNode class\',\'\',\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'\',\'public class CitiesDriver { \',\'	public static void main(String[] args) {\',\'		Scanner sc = new Scanner(System.in);\',\'		int n = sc.nextInt(); // number of cities\',\'		MyTree[] cities = new MyTree[n];\',\'\',\'		// read isSafe\',\'		for  ( int i = 0; i < n; i++ ) {\',\'			cities[i] = new MyTree(i);\',\'			int isSafe = sc.nextInt();\',\'			if(isSafe == 1)\',\'				cities[i].isSafe = true;\',\'			else \',\'				cities[i].isSafe = false;\',\'		} \',\'\',\'		// read children\',\'		for ( int i = 0; i < n; i++ ) {\',\'			int left = sc.nextInt();\',\'			int right = sc.nextInt();\',\'			cities[i].leftIndex = left;\',\'			cities[i].rightIndex = right;\',\'		}\',\'\',\'		// read queries\',\'		int m = sc.nextInt( ); // number of queries\',\'		for( int i=0; i<m; i++ ){\',\'			int beg = sc.nextInt( );\',\'			int end = sc.nextInt( );\',\'			if( findSafePath(cities, beg, end) )\',\'				System.out.println(\"YES\");\',\'		    else \',\'				System.out.println(\"NO\");\',\'		}\',\'	} // end main\',\'\',\'	private static boolean findSafePath ( MyTree[] cities, int beg, int end ) {\',\'		if( !cities[beg].isSafe ) \',\'			return false;\',\'		else if ( !cities[end].isSafe )\',\'			return false;\',\'		else { // both are safe\',\'			MyTree curr1 = cities[beg];\',\'			MyTree curr2 = cities[end];\',\'\',\'			if( curr1.city ==0 ) { // beg is root\',\'				if(curr2.city ==0 ) // end is root\',\'					return true; // checked already\',\'				else { // end is not root\',\'					while(curr2.city != 0) { // not root\',\'						if ( !curr2.isSafe )\',\'							return false;\',\'						curr2 = getParent(cities, curr2.city);\',\'					}\',\'					return true;\',\'				}\',\'			} // end beg is root\',\'			else if( curr2.city == 0 ) { // end is root\',\'				if(curr1.city ==0 ) // beg is root\',\'					return true;\',\'				else { // beg is not root\',\'					while(curr1.city != 0) {\',\'						if ( !curr1.isSafe )\',\'							return false;\',\'						curr1 = getParent(cities, curr1.city);\',\'					}\',\'					return true;\',\'				}\',\'			} // end of the case end is root\',\'			else { // both are not root\',\'				while(curr1.city != 0 && curr1.city != end) {\',\'					if(!curr1.isSafe)\',\'						return false;\',\'					curr1 = getParent(cities, curr1.city);\',\'				}\',\'				if( curr1.city == end ) {\',\'					if(cities[end].isSafe)\',\'						return true;\',\'					else \',\'						return false;\',\'				}\',\'				else { // curr1 reaches root\',\'					while(curr2.city != 0 && curr2.city != beg) {\',\'						if (!curr2.isSafe)\',\'							return false;\',\'						curr2 = getParent(cities,curr2.city);\',\'					}\',\'					if(curr2.city == beg) {\',\'						if(cities[beg].isSafe)\',\'							return true;\',\'						else \',\'							return false;\',\'					}\',\'					else { // both reach root\',\'						if(cities[0].isSafe) // root is safe\',\'							return true;\',\'						else \',\'							return false;\',\'					} // end both reaches root\',\'				} // end curr1 reaches root\',\'			} // end both are not root\',\'		} // both are safe\',\'	} // end findSafePath\',\'\',\'	private static MyTree getParent(MyTree[] cities, int child) {\',\'		for ( int i = 0; i < cities.length; i++ ) {\',\'			if(cities[i].leftIndex == child || cities[i].rightIndex == child)\',\'				return cities[i];\',\'		}\',\'		return null;\',\'	} // end getParent\',\'\',\'} //  end CitiesDriver class\',\'\'',9,0,'2012-06-18 18:30:59','2012-06-18 18:30:59'),(10,155,'\'/** Class for a tree node\',\' */\',\'class MyNode {\',\'    // You may use this class if you\\\'d like.  It may help you if you use\',\'    // an array based implementation of a binary tree\',\'\',\'    // you can add other variables if you\\\'d like\',\'    boolean isSafe;				  // is the city safe?\',\'    int leftChildIndex;			  // left child index in array\',\'    int rightChildIndex;		 // right child index in array\',\'\',\'    public MyNode(int safe, int left, int right){\',\'		if(safe==1) isSafe=true;\',\'		else isSafe=false;\',\'		leftChildIndex=left;\',\'		rightChildIndex=right;\',\'	}\',\'	// fill in your accessor and mutator methods here\',\'    // ...\',\'	public int getLeftIndex(){\',\'		return leftChildIndex;\',\'	}\',\'	public int getRightIndex(){\',\'		return rightChildIndex;\',\'	}\',\'	public void setLeftIndex(int left){\',\'		leftChildIndex=left;\',\'	}\',\'	public void setRightIndex(int right){\',\'		rightChildIndex=right;\',\'	}\',\'\',\'}\',\'\',\'/** Class for a binary tree ADT\',\' */\',\'public class MyTree {\',\'    // You may want to use an array based implementation for \',\'    // your tree, or change this to another implementation\',\'\',\'    // Note that this code and the driver code do not necessarily\',\'    // match well -- you decide how you want these two parts to work\',\'    // together.\',\'\',\'    private final int MAX_NODES = 1000;\',\'    MyNode[] myTree = new MyNode[MAX_NODES];\',\'    int size = 0;	// make sure to update this variable as needed\',\'\',\'    // fill in your ADT methods here\',\'    // ...\',\'	public MyTree(int n){\',\'		size=n;\',\'		for(int i=0;i<n;i++)\',\'			myTree[i]=new MyNode(0,-1,-1);\',\'		}\',\'\',\'	public void setSafe(int i, int safe){\',\'		if(safe==1) myTree[i].isSafe=true;\',\'		else myTree[i].isSafe=false;\',\'\',\'	}\',\'	public void setChild(int i,int left, int right){\',\'		myTree[i].setLeftIndex(left);\',\'		myTree[i].setRightIndex(right);\',\'	}\',\'	public boolean  safeToTwo(int root, int i,int j){\',\'	    return (safeToOne(root,i)&&safeToOne(root,j));\',\'	}\',\'	public boolean safeToOne(int root, int i){\',\'	/*	if((myTree[root].getLeftIndex()==i&&myTree[root].getLeftIndex().isSafe)||\',\'			(myTree[root].getRightIndex()==i&&myTree[root].getRightIndex().isSafe))\',\'		return myTree[i].isSafe;\',\'			else return safeToOne(myTree[root].getLeftIndex(),i)||safeToOne(myTree[root].getRightIndex(),i);\',\'	*/\',\'	return false;\',\'	}\',\'		\',\'\',\'\',\'\',\'}\',\'\',\'import java.util.*;\',\'\',\'/**\',\' * Driver class, you may have to change it to fit your implementation\',\' * Make sure you compile and run this class\',\' */\',\'public class CitiesDriver {\',\'    static Scanner sc;\',\'	static MyTree citytree;\',\'	static Query[] q;\',\'    \',\'    /** Read in the tree\',\'     */\',\'    public static void readTree () {\',\'	/// Read in the tree\',\'	// read in one integer\',\'	int n = sc.nextInt();\',\'	citytree = new MyTree(n);\',\'	// read in tree, safety line\',\'	for (int i=0;i<n;i++) {\',\'	    int safe=sc.nextInt();			   // modify this line\',\'	    citytree.setSafe(i,safe);\',\'	}\',\'	// loop to read pairs of children\',\'	for (int i=0;i<n;i++) {\',\'	    int left=sc.nextInt();			   // modify this line\',\'	    int right=sc.nextInt();\',\'		citytree.setChild(i,left,right);// modify this line\',\'	}\',\'    }\',\'    \',\'    /** Read in query statements\',\'     */\',\'    public static void readQueries () {\',\'	// read in one integer\',\'	int m = sc.nextInt();\',\'	q = new Query[m];\',\'	// loop to read pairs of children for query\',\'	for (int i=0;i<m;i++) {\',\'	    int a=sc.nextInt();			   // modify this line\',\'	    int b=sc.nextInt();			   // modify this line\',\'		q[i]=new Query(a,b);\',\'	}\',\'    }\',\'    \',\'    public static void main(String[] args) {\',\'	sc = new Scanner(System.in);\',\'	readTree();				   // read in the tree\',\'	readQueries();				// read in the queries\',\'\',\'	for(int i=0;i<10;i++){\',\'		if(safetravel(q[i].start,q[i].end))\',\'			System.out.println(\"YES\");\',\'			else System.out.println(\"No\");\',\'\',\'    }\',\'	}\',\'\',\'	public static boolean safetravel(int i, int j){\',\'		return citytree.safeToTwo(0,i,j);\',\'	}\',\'}\',\'\',\'	class Query{\',\'		int start;\',\'		int end;\',\'		public Query(int a,int b){\',\'			start=a;\',\'			end=b;\',\'		}\',\'\',\'}\',\'\'',10,0,'2012-06-18 18:30:59','2012-06-18 18:30:59');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `assignment_sim_results` (
  `id` int(11) NOT NULL auto_increment,
  `assignment_id` int(11) default NULL,
  `id1` int(11) default NULL,
  `id2` int(11) default NULL,
  `sim1To2` decimal(5,3) default NULL,
  `sim2To1` decimal(5,3) default NULL,
  `sim` decimal(5,3) default NULL,
  `status` int(11) NOT NULL default '0',
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_assignment_sim_results_on_assignment_id_and_id1_and_id2` (`assignment_id`,`id1`,`id2`),
  KEY `index_assignment_sim_results_on_assignment_id_and_sim` (`assignment_id`,`sim`),
  KEY `index_assignment_sim_results_on_assignment_id_and_sim1To2` (`assignment_id`,`sim1To2`),
  KEY `index_assignment_sim_results_on_assignment_id_and_sim2To1` (`assignment_id`,`sim2To1`),
  KEY `index_aId_sims` (`assignment_id`,`sim1To2`,`sim2To1`),
  KEY `index_assignment_sim_results_on_assignment_id` (`assignment_id`),
  KEY `index_a_status` (`assignment_id`,`status`)
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `assignment_sim_results` VALUES (1,1,1,2,'7.792','6.194','7.792',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(2,1,1,3,'7.792','6.210','7.792',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(3,1,4,1,'0.000','0.000','0.000',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(4,1,1,5,'7.792','6.349','7.792',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(5,1,6,1,'2.901','2.435','2.901',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(6,1,1,7,'7.792','6.349','7.792',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(7,1,1,8,'7.792','6.210','7.792',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(8,1,1,9,'2.435','2.104','2.435',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(9,1,10,1,'11.356','10.877','11.356',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(10,1,3,2,'92.238','92.000','92.238',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(11,1,4,2,'4.571','2.065','4.571',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(12,1,5,2,'19.048','18.581','19.048',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(13,1,6,2,'22.824','15.226','22.824',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(14,1,7,2,'19.048','18.581','19.048',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(15,1,8,2,'81.630','81.419','81.630',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(16,1,9,2,'9.257','8.516','9.257',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(17,1,10,2,'30.169','22.968','30.169',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(18,1,4,3,'4.571','2.070','4.571',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(19,1,5,3,'19.974','19.534','19.974',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(20,1,6,3,'29.594','19.793','29.594',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(21,1,7,3,'19.974','19.534','19.974',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(22,1,8,3,'91.462','91.462','91.462',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(23,1,9,3,'11.501','10.608','11.501',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(24,1,10,3,'37.797','28.849','37.797',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(25,1,4,5,'4.571','2.116','4.571',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(26,1,4,6,'0.000','0.000','0.000',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(27,1,4,7,'4.571','2.116','4.571',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(28,1,4,8,'6.286','2.846','6.286',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(29,1,4,9,'0.000','0.000','0.000',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(30,1,4,10,'10.857','6.441','10.857',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(31,1,6,5,'7.157','4.894','7.157',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(32,1,7,5,'99.603','99.603','99.603',2,'2012-06-18 18:31:00','2012-06-18 10:35:32'),(33,1,5,8,'14.418','14.101','14.418',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(34,1,9,5,'4.067','3.836','4.067',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(35,1,10,5,'23.390','18.254','23.390',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(36,1,6,7,'7.157','4.894','7.157',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(37,1,6,8,'24.952','16.688','24.952',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(38,1,6,9,'24.952','18.093','24.952',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(39,1,6,10,'30.948','27.119','30.948',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(40,1,7,8,'14.418','14.101','14.418',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(41,1,9,7,'4.067','3.836','4.067',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(42,1,10,7,'23.390','18.254','23.390',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(43,1,9,8,'11.501','10.608','11.501',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(44,1,10,8,'35.763','27.296','35.763',0,'2012-06-18 18:31:00','2012-06-18 18:31:00'),(45,1,10,9,'17.627','14.586','17.627',0,'2012-06-18 18:31:00','2012-06-18 18:31:00');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `assignments` (
  `id` int(11) NOT NULL auto_increment,
  `title` varchar(255) default NULL,
  `language` varchar(255) default NULL,
  `course_id` int(11) NOT NULL,
  `status` int(11) default '-1',
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_assignments_on_course_id` (`course_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `assignments` VALUES (1,'Take Home 1','java',2,0,'2012-06-18 10:30:20','2012-06-18 10:31:08');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `check_plag_ids` (
  `id` int(11) NOT NULL auto_increment,
  `assignment_id` int(11) default NULL,
  `pid` int(11) default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_check_plag_ids_on_assignment_id` (`assignment_id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `courses` (
  `id` int(11) NOT NULL auto_increment,
  `code` varchar(255) default NULL,
  `name` varchar(255) default NULL,
  `academic_year` varchar(255) default NULL,
  `semester` int(11) default NULL,
  `expiry` datetime default NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `index_courses_on_code_and_academic_year_and_semester` (`code`,`academic_year`,`semester`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `courses` VALUES (1,'CS1101','Programming Methodology','09/10',2,'2020-07-01 15:59:59','2012-06-18 09:23:20','2012-06-18 09:23:20'),(2,'CS1102','Data Structures and Alogrithms','09/10',2,'2020-07-01 15:59:59','2012-06-18 09:23:20','2012-06-18 09:23:20');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `plag_logs` (
  `id` int(11) NOT NULL auto_increment,
  `student_id` int(11) default NULL,
  `account_id` int(11) default NULL,
  `assignment_code_id` int(11) default NULL,
  `assignment_sim_result_id` int(11) default NULL,
  `log_type` int(11) NOT NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_plag_logs_on_student_id` (`student_id`),
  KEY `index_plag_logs_on_account_id` (`account_id`),
  KEY `index_plag_logs_on_assignment_code_id` (`assignment_code_id`),
  KEY `index_plag_logs_on_assignment_sim_result_id` (`assignment_sim_result_id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `plag_logs` VALUES (1,7,3,7,32,0,'2012-06-18 10:35:27','2012-06-18 10:35:27'),(2,5,3,5,32,0,'2012-06-18 10:35:27','2012-06-18 10:35:27'),(3,7,3,7,32,2,'2012-06-18 10:35:32','2012-06-18 10:35:32'),(4,5,3,5,32,2,'2012-06-18 10:35:32','2012-06-18 10:35:32'),(5,5,3,5,32,3,'2012-06-18 10:35:32','2012-06-18 10:35:32');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `schema_migrations` (
  `version` varchar(255) NOT NULL,
  UNIQUE KEY `unique_schema_migrations` (`version`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `schema_migrations` VALUES ('20090723172236'),('20090725092112'),('20090726092712'),('20090726144949'),('20090814152422'),('20090815085255'),('20091217180519'),('20091222061417'),('20091222061502'),('20091222064522'),('20100305124145'),('20100306043653'),('20100308115754'),('20100714071348'),('20100714071350');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sim_mappings` (
  `id` int(11) NOT NULL auto_increment,
  `result_id` int(11) default NULL,
  `startIndex1` int(11) default NULL,
  `endIndex1` int(11) default NULL,
  `startIndex2` int(11) default NULL,
  `endIndex2` int(11) default NULL,
  `startLine1` int(11) default NULL,
  `endLine1` int(11) default NULL,
  `startLine2` int(11) default NULL,
  `endLine2` int(11) default NULL,
  `stmtMappedCount` int(11) default NULL,
  `isPlagMapping` tinyint(1) default NULL,
  PRIMARY KEY  (`id`),
  KEY `index_sim_mappings_on_result_id` (`result_id`)
) ENGINE=InnoDB AUTO_INCREMENT=275 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `sim_mappings` VALUES (1,1,844,1299,1527,1683,40,56,87,97,4,0),(2,1,30,348,924,1019,2,9,56,60,3,0),(3,1,3996,4120,772,884,156,159,45,48,3,0),(4,1,561,660,1397,1495,22,27,80,84,2,1),(5,1,1513,1581,1975,2033,64,65,111,112,2,1),(6,1,4319,4379,698,761,165,166,39,41,2,1),(7,1,2364,2556,0,73,95,102,0,4,1,0),(8,2,817,1299,1909,2394,39,56,87,104,4,0),(9,2,30,348,1265,1406,2,9,58,61,3,0),(10,2,3996,4120,1055,1182,156,159,47,50,3,0),(11,2,561,660,1755,1853,22,27,78,82,2,1),(12,2,1513,1581,2791,2849,64,65,121,122,2,1),(13,2,4319,4379,981,1044,165,166,41,43,2,1),(14,2,2364,2556,0,189,95,102,0,7,1,0),(15,3,2491,2615,3996,4120,110,113,156,159,3,0),(16,3,30,165,30,290,2,6,2,8,2,0),(17,3,1587,1779,2364,2556,72,79,95,102,1,0),(18,4,901,1299,1682,1806,46,56,100,104,3,0),(19,4,30,348,1071,1193,2,9,59,63,3,0),(20,4,3996,4120,876,1003,156,159,49,52,3,0),(21,4,561,660,1300,1377,22,27,71,76,2,1),(22,4,1513,1581,2058,2118,64,65,118,119,2,1),(23,4,4319,4379,795,854,165,166,43,44,2,1),(24,4,2364,2556,0,96,95,102,0,8,1,0),(25,5,50,190,30,348,3,6,2,9,3,0),(26,5,263,386,901,1299,11,14,46,56,3,0),(27,5,2281,2342,4319,4379,86,87,165,166,2,1),(28,5,2452,2504,4068,4120,94,95,158,159,2,0),(29,5,1315,1507,2364,2556,47,54,95,102,1,0),(30,6,901,1299,1772,1896,46,56,103,107,3,0),(31,6,30,348,1161,1283,2,9,62,66,3,0),(32,6,3996,4120,966,1093,156,159,52,55,3,0),(33,6,561,660,1390,1467,22,27,74,79,2,1),(34,6,1513,1581,2148,2208,64,65,121,122,2,1),(35,6,4319,4379,870,939,165,166,43,46,2,1),(36,6,2364,2556,0,103,95,102,0,8,1,0),(37,7,817,1299,1893,2370,39,56,94,111,4,0),(38,7,30,348,1266,1391,2,9,65,68,3,0),(39,7,3996,4120,217,341,156,159,11,15,3,0),(40,7,561,660,1742,1836,22,27,85,89,2,1),(41,7,1513,1581,2600,2660,64,65,121,122,2,1),(42,7,4319,4379,664,727,165,166,30,32,2,1),(43,7,2364,2556,0,189,95,102,0,7,1,0),(44,8,226,348,190,318,7,9,9,11,3,0),(45,8,4319,4379,1400,1467,165,166,59,61,2,1),(46,9,878,1276,901,1299,36,46,46,56,3,0),(47,9,30,348,30,348,2,9,2,9,3,0),(48,9,3279,3403,3996,4120,127,130,156,159,3,0),(49,9,2134,2352,2348,2556,74,89,91,102,2,0),(50,9,595,703,561,660,19,23,22,27,2,1),(51,9,1632,1694,1513,1581,62,63,64,65,2,1),(52,9,3497,3556,4319,4379,134,135,165,166,2,1),(53,9,435,479,477,537,12,13,15,18,2,1),(54,10,1939,5168,1527,3158,88,179,87,156,37,1),(55,10,723,1456,490,1039,33,62,31,61,12,1),(56,10,1568,1853,1210,1495,69,82,71,84,5,1),(57,10,0,372,0,187,0,16,0,12,4,1),(58,10,591,677,360,456,25,27,24,26,3,1),(59,10,465,519,237,296,19,20,17,18,2,1),(60,11,2491,2615,772,884,110,113,45,48,3,0),(61,11,1762,1923,76,163,79,86,5,11,2,0),(62,11,30,165,924,990,2,6,56,59,2,0),(63,11,519,613,1243,1328,21,25,72,75,2,1),(64,12,795,1003,698,884,43,52,39,48,5,1),(65,12,0,280,0,187,0,18,0,12,4,1),(66,12,1682,1806,1555,1683,100,104,92,97,3,0),(67,12,1071,1193,924,1019,59,63,56,60,3,0),(68,12,2001,2118,1918,2033,117,119,110,112,2,1),(69,12,1532,1637,1270,1391,88,93,74,78,2,1),(70,12,1300,1377,1448,1545,71,76,83,87,2,1),(71,13,1315,1668,0,163,47,61,0,11,3,0),(72,13,2006,2218,490,651,77,83,31,37,3,1),(73,13,0,190,903,1019,0,6,54,60,3,0),(74,13,2281,2431,698,847,86,92,39,46,3,1),(75,13,263,386,1555,1683,11,14,92,97,3,0),(76,13,1855,1943,360,456,69,71,24,26,3,1),(77,13,1729,1786,237,296,64,65,17,18,2,1),(78,13,2452,2504,851,884,94,95,47,48,2,0),(79,14,870,1093,698,884,43,55,39,48,5,1),(80,14,0,321,0,187,0,18,0,12,4,1),(81,14,1772,1896,1555,1683,103,107,92,97,3,0),(82,14,1161,1283,924,1019,62,66,56,60,3,0),(83,14,2091,2208,1918,2033,120,122,110,112,2,1),(84,14,1622,1727,1270,1391,91,96,74,78,2,1),(85,14,1390,1467,1448,1545,74,79,83,87,2,1),(86,15,4002,5345,2144,3158,151,190,119,156,24,1),(87,15,1558,1885,1210,1545,76,92,71,87,6,1),(88,15,1984,2412,1555,1723,101,113,92,99,5,1),(89,15,2541,2774,1918,2137,120,126,110,116,4,1),(90,15,1246,1437,903,1039,64,69,54,61,4,0),(91,15,414,619,490,651,22,28,31,37,3,1),(92,15,2782,2971,1730,1912,128,134,102,108,3,1),(93,15,217,341,772,884,11,15,45,48,3,0),(94,15,1113,1199,360,456,51,53,24,26,3,1),(95,15,0,210,0,94,0,8,0,5,2,0),(96,15,765,896,100,187,38,42,9,12,2,1),(97,15,664,727,698,761,30,32,39,41,2,1),(98,15,991,1041,237,296,45,46,17,18,2,1),(99,16,190,318,943,1019,9,11,57,60,3,0),(100,16,1228,1354,531,651,54,57,33,37,3,1),(101,16,1400,1467,698,761,59,61,39,41,2,1),(102,16,1085,1137,360,422,47,48,24,25,2,1),(103,17,878,1276,1555,1683,36,46,92,97,3,0),(104,17,30,348,924,1019,2,9,56,60,3,0),(105,17,506,703,1371,1495,15,23,78,84,3,1),(106,17,3279,3403,772,884,127,130,45,48,3,0),(107,17,2776,2886,360,456,107,109,24,26,3,1),(108,17,2160,2377,0,94,82,90,0,5,2,0),(109,17,2440,2567,100,187,95,99,9,12,2,1),(110,17,709,833,1210,1328,25,29,71,75,2,1),(111,17,1581,1694,1918,2033,61,63,110,112,2,1),(112,17,3114,3211,563,651,120,122,35,37,2,1),(113,17,2629,2706,237,296,102,103,17,18,2,1),(114,17,3497,3556,698,761,134,135,39,41,2,1),(115,18,2491,2615,1055,1182,110,113,47,50,3,0),(116,18,1762,1923,192,348,79,86,8,15,2,0),(117,18,30,165,1265,1348,2,6,58,60,2,0),(118,18,519,613,1549,1622,21,25,67,70,2,1),(119,19,795,1003,981,1182,43,52,41,50,5,1),(120,19,0,280,0,372,0,18,0,16,4,1),(121,19,1300,1426,1806,1952,71,80,81,88,3,1),(122,19,1682,1806,1996,2394,100,104,94,104,3,0),(123,19,1071,1193,1265,1406,59,63,58,61,3,0),(124,19,2001,2118,2734,2849,117,119,120,122,2,1),(125,19,1532,1637,1628,1749,88,93,72,76,2,1),(126,20,1701,2218,438,934,63,83,18,39,8,1),(127,20,1315,1668,0,348,47,61,0,15,3,0),(128,20,0,190,1245,1406,0,6,57,61,3,0),(129,20,2281,2431,981,1125,86,92,41,48,3,1),(130,20,263,386,1996,2394,11,14,94,104,3,0),(131,20,2452,2504,1129,1182,94,95,49,50,2,0),(132,21,870,1093,981,1182,43,55,41,50,5,1),(133,21,0,321,0,372,0,18,0,16,4,1),(134,21,1390,1516,1806,1952,74,83,81,88,3,1),(135,21,1772,1896,1996,2394,103,107,94,104,3,0),(136,21,1161,1283,1265,1406,62,66,58,61,3,0),(137,21,2091,2208,2734,2849,120,122,120,122,2,1),(138,21,1622,1727,1628,1749,91,96,72,76,2,1),(139,22,4002,5345,3950,5168,151,190,142,179,24,1),(140,22,1246,2412,1245,2434,64,113,57,106,17,1),(141,22,765,1199,241,677,38,53,12,27,7,1),(142,22,2541,2774,2734,2953,120,126,120,126,4,1),(143,22,414,619,723,934,22,28,33,39,3,1),(144,22,2782,2971,2550,2728,128,134,112,118,3,1),(145,22,217,341,1055,1182,11,15,47,50,3,0),(146,22,0,210,0,210,0,8,0,8,2,0),(147,22,664,727,981,1044,30,32,41,43,2,1),(148,23,190,318,1284,1406,9,11,59,61,3,0),(149,23,1228,1354,786,934,54,57,35,39,3,1),(150,23,1050,1137,564,643,46,48,24,26,2,1),(151,23,1400,1467,981,1044,59,61,41,43,2,1),(152,24,2440,3047,241,806,95,117,12,35,8,1),(153,24,878,1276,1996,2394,36,46,94,104,3,0),(154,24,30,348,1265,1406,2,9,58,61,3,0),(155,24,506,703,1729,1853,15,23,76,82,3,1),(156,24,3279,3403,1055,1182,127,130,47,50,3,0),(157,24,2160,2377,0,210,82,90,0,8,2,0),(158,24,709,833,1568,1686,25,29,69,73,2,1),(159,24,1581,1694,2734,2849,61,63,120,122,2,1),(160,24,3114,3211,856,934,120,122,37,39,2,1),(161,24,3497,3556,981,1044,134,135,41,43,2,1),(162,25,2491,2615,876,1003,110,113,49,52,3,0),(163,25,1762,1923,99,253,79,86,9,16,2,0),(164,25,30,165,1071,1145,2,6,59,62,2,0),(165,25,519,613,1568,1637,21,25,89,93,2,1),(166,26,1762,1923,1513,1668,79,86,55,61,2,0),(167,26,30,165,50,132,2,6,3,5,2,0),(168,26,2563,2615,2452,2504,112,113,94,95,2,0),(169,27,2491,2615,966,1093,110,113,52,55,3,0),(170,27,1762,1923,109,282,79,86,9,16,2,0),(171,27,30,165,1161,1235,2,6,62,65,2,0),(172,27,519,613,1658,1727,21,25,92,96,2,1),(173,28,2491,2615,217,341,110,113,11,15,3,0),(174,28,30,165,1266,1340,2,6,65,67,2,0),(175,28,519,613,1537,1609,21,25,74,77,2,1),(176,28,171,229,172,210,7,8,7,8,2,1),(177,29,108,165,190,259,5,6,9,10,2,0),(178,30,2491,2615,3279,3403,110,113,127,130,3,0),(179,30,30,165,30,290,2,6,2,8,2,0),(180,30,519,613,747,833,21,25,26,29,2,1),(181,30,171,229,2335,2377,7,8,89,90,2,1),(182,30,339,373,3730,3747,13,14,149,150,2,1),(183,30,481,515,483,527,19,20,14,15,2,1),(184,31,1315,1668,0,253,47,61,0,16,3,0),(185,31,2281,2431,795,946,86,92,43,50,3,1),(186,31,50,190,1071,1193,3,6,59,63,3,0),(187,31,263,386,1682,1806,11,14,100,104,3,0),(188,31,2452,2504,950,1003,94,95,51,52,2,0),(189,32,0,3423,0,3300,0,184,0,177,54,1),(190,33,876,1003,217,341,49,52,11,15,3,0),(191,33,1300,1426,1792,1938,71,80,88,95,3,1),(192,33,1682,1806,1984,2370,100,104,101,111,3,0),(193,33,1071,1193,1266,1391,59,63,65,68,3,0),(194,33,148,280,765,896,12,18,38,42,2,1),(195,33,0,117,0,210,0,9,0,8,2,0),(196,33,2001,2118,2541,2660,117,119,120,122,2,1),(197,33,1532,1637,1617,1734,88,93,79,83,2,1),(198,33,795,854,664,727,43,44,30,32,2,1),(199,34,190,318,1091,1193,9,11,61,63,3,0),(200,34,411,462,1253,1293,16,18,66,68,3,1),(201,34,1400,1467,795,854,59,61,43,44,2,1),(202,35,709,1405,1532,1844,25,51,88,107,6,1),(203,35,30,348,1071,1193,2,9,59,63,3,0),(204,35,3279,3403,876,1003,127,130,49,52,3,0),(205,35,2160,2377,0,117,82,90,0,9,2,0),(206,35,2440,2567,148,280,95,99,12,18,2,1),(207,35,1581,1694,2001,2118,61,63,117,119,2,1),(208,35,595,703,1300,1377,19,23,71,76,2,1),(209,35,3497,3556,795,854,134,135,43,44,2,1),(210,36,1315,1668,0,282,47,61,0,16,3,0),(211,36,2281,2431,870,1036,86,92,43,53,3,1),(212,36,50,190,1161,1283,3,6,62,66,3,0),(213,36,263,386,1772,1896,11,14,103,107,3,0),(214,36,2452,2504,1040,1093,94,95,54,55,2,0),(215,37,1701,1943,962,1199,63,71,44,53,5,1),(216,37,2006,2218,414,619,77,83,22,28,3,1),(217,37,0,190,1246,1391,0,6,64,68,3,0),(218,37,263,386,1984,2370,11,14,101,111,3,0),(219,37,1315,1529,0,210,47,55,0,8,2,0),(220,37,2281,2342,664,727,86,87,30,32,2,1),(221,37,2452,2504,294,341,94,95,14,15,2,0),(222,38,2067,2218,1228,1354,79,83,54,57,3,1),(223,38,68,190,190,318,4,6,9,11,3,0),(224,38,533,617,939,1021,19,21,39,42,2,1),(225,38,1827,1909,1050,1137,68,70,46,48,2,1),(226,38,686,766,1142,1201,25,26,49,50,2,1),(227,38,2281,2342,1400,1467,86,87,59,61,2,1),(228,39,1701,2087,2600,3047,63,79,101,117,6,1),(229,39,50,190,30,348,3,6,2,9,3,0),(230,39,263,386,878,1276,11,14,36,46,3,0),(231,39,1315,1529,2160,2377,47,55,82,90,2,0),(232,39,533,617,1510,1574,19,21,57,58,2,1),(233,39,2135,2218,3114,3211,81,83,120,122,2,1),(234,39,2281,2342,3497,3556,86,87,134,135,2,1),(235,39,2452,2504,3351,3403,94,95,129,130,2,0),(236,40,966,1093,217,341,52,55,11,15,3,0),(237,40,1390,1516,1792,1938,74,83,88,95,3,1),(238,40,1772,1896,1984,2370,103,107,101,111,3,0),(239,40,1161,1283,1266,1391,62,66,65,68,3,0),(240,40,165,321,765,896,12,18,38,42,2,1),(241,40,0,134,0,210,0,9,0,8,2,0),(242,40,2091,2208,2541,2660,120,122,120,122,2,1),(243,40,1622,1727,1617,1734,91,96,79,83,2,1),(244,40,870,939,664,727,43,46,30,32,2,1),(245,41,190,318,1181,1283,9,11,64,66,3,0),(246,41,411,462,1343,1383,16,18,69,71,3,1),(247,41,1400,1467,870,939,59,61,43,46,2,1),(248,42,709,1405,1622,1934,25,51,91,110,6,1),(249,42,30,348,1161,1283,2,9,62,66,3,0),(250,42,3279,3403,966,1093,127,130,52,55,3,0),(251,42,2160,2377,0,134,82,90,0,9,2,0),(252,42,2440,2567,165,321,95,99,12,18,2,1),(253,42,1581,1694,2091,2208,61,63,120,122,2,1),(254,42,595,703,1390,1467,19,23,74,79,2,1),(255,42,3497,3556,870,939,134,135,43,46,2,1),(256,43,190,318,1283,1391,9,11,66,68,3,0),(257,43,1228,1354,471,619,54,57,24,28,3,1),(258,43,1050,1137,1086,1165,46,48,50,52,2,1),(259,43,1400,1467,664,727,59,61,30,32,2,1),(260,44,2440,2886,765,1199,95,109,38,53,7,1),(261,44,878,1276,1984,2370,36,46,101,111,3,0),(262,44,30,348,1266,1391,2,9,65,68,3,0),(263,44,506,703,1719,1836,15,23,83,89,3,1),(264,44,3279,3403,217,341,127,130,11,15,3,0),(265,44,2160,2377,0,210,82,90,0,8,2,0),(266,44,709,833,1558,1672,25,29,76,80,2,1),(267,44,1581,1694,2541,2660,61,63,120,122,2,1),(268,44,3114,3211,541,619,120,122,26,28,2,1),(269,44,3497,3556,664,727,134,135,30,32,2,1),(270,45,226,348,190,318,7,9,9,11,3,0),(271,45,2747,2851,1050,1137,106,108,46,48,2,1),(272,45,3114,3211,1274,1354,120,122,55,57,2,1),(273,45,1510,1574,939,1021,57,58,39,42,2,1),(274,45,3497,3556,1400,1467,134,135,59,61,2,1);
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `students` (
  `id` int(11) NOT NULL auto_increment,
  `matric` varchar(255) default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `index_students_on_matric` (`matric`)
) ENGINE=InnoDB AUTO_INCREMENT=11 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `students` VALUES (4,'01'),(5,'02'),(7,'03'),(3,'04'),(8,'05'),(2,'06'),(1,'07'),(9,'08'),(6,'09'),(10,'10');
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `teachings` (
  `id` int(11) NOT NULL auto_increment,
  `account_id` int(11) NOT NULL,
  `course_id` int(11) NOT NULL,
  `role` int(11) NOT NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`),
  UNIQUE KEY `index_teachings_on_account_id_and_course_id` (`account_id`,`course_id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
/*!40101 SET character_set_client = @saved_cs_client */;
INSERT INTO `teachings` VALUES (1,2,1,0,'2012-06-18 09:23:20','2012-06-18 09:23:20'),(2,3,2,0,'2012-06-18 09:23:20','2012-06-18 09:23:20'),(3,4,1,1,'2012-06-18 09:23:21','2012-06-18 09:23:21'),(4,5,2,1,'2012-06-18 09:23:21','2012-06-18 09:23:21');

/*!50003 SET @OLD_SQL_MODE=@@SQL_MODE*/;
DELIMITER ;;
/*!50003 SET SESSION SQL_MODE=""*/;;
/*!50003 CREATE*/ /*!50020 DEFINER=CURRENT_USER*/ /*!50003 FUNCTION `higherFloat`(val1 FLOAT, val2 FLOAT) RETURNS float
begin if val1 > val2 then return val1; else return val2; end if; end */;;
/*!50003 SET SESSION SQL_MODE=@OLD_SQL_MODE*/;;
/*!50003 SET SESSION SQL_MODE=""*/;;
/*!50003 CREATE*/ /*!50020 DEFINER=CURRENT_USER*/ /*!50003 FUNCTION `higherInt`(val1 FLOAT, val2 FLOAT) RETURNS int(11)
begin if val1 > val2 then return round(val1 * 100); else return round(val2 * 100); end if; end */;;
/*!50003 SET SESSION SQL_MODE=@OLD_SQL_MODE*/;;
/*!50003 SET SESSION SQL_MODE=""*/;;
/*!50003 CREATE*/ /*!50020 DEFINER=CURRENT_USER*/ /*!50003 PROCEDURE `ttable`()
begin truncate table assignments; truncate table assignment_cluster_members; truncate table assignment_clusterings; truncate table assignment_clusters; truncate table assignment_codes; truncate table assignment_sim_results; truncate table students; truncate table sim_mappings; truncate table plag_logs; end */;;
/*!50003 SET SESSION SQL_MODE=@OLD_SQL_MODE*/;;
DELIMITER ;
